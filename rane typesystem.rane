// typesystem.rane
// "Real" type-system fixture for the RANE bootstrap compiler.
//
// This file is a focused compilation fixture demonstrating the *implemented* type surface:
// - Primitive type names used by `load/store`: u8/u16/u32/u64, i8/i16/i32/i64, p64, b1/bool
// - Literal types: integers -> u64, bool -> b1, strings -> text, null -> p64
// - v1 user-defined struct declarations + typed `set` declarations
// - Typechecker behavior (as implemented in `rane_typecheck.cpp`):
//   - numeric ops unify to u64
//   - comparisons yield b1
//   - logical and/or require b1 operands
//   - ternary branches must have same type
//   - load/store require pointer-like addresses; store requires exact value type match
//   - `say` accepts text|bytes
//
// NOTE: This file intentionally avoids unimplemented statement forms (`let` in current parser branch, etc.).
// Use `tests/exhaustive_exprs.rane` for the proc/let/expression-heavy coverage.

module typesystem

// Basic user-defined type (v1 surface).
struct Header:
  magic: u32
  version: u16
  flags: u16
  size: u64
end

struct PairU64:
  a: u64
  b: u64
end

node main:
  // --- literals and their inferred types (typechecker) ---
  set t0: bool to true
  set t1: b1 to false

  set i0: u64 to 0
  set i1: u64 to 1_000_000
  set i2: u64 to 0xCAFE_BABE
  set i3: u64 to 0b1010_0101

  set p0: p64 to null

  // Strings are `text` in the current implementation (EXPR_LIT_TEXT => RANE_TYPE_TEXT)
  set s0: text to "hello"
  say s0
  say "direct literal ok"

  // --- boolean ops (must be b1 operands) ---
  set c0: b1 to (i0 < i1)
  set c1: b1 to (i0 == i1)
  set c2: b1 to (c0 and c1)
  set c3: b1 to (c0 or c1)
  say "bool ops ok"

  // --- ternary: branches must match types ---
  set pick: u64 to (c0 ? i0 : i1)
  set pick2: text to (c0 ? "a" : "b")
  say pick2

  // --- numeric ops: unified to u64 in bootstrap typechecker ---
  set n0: u64 to (i1 + i2)
  set n1: u64 to (i1 - i0)
  set n2: u64 to (i1 * 2)
  set n3: u64 to (i1 / 2)
  set n4: u64 to (i1 % 3)
  set n5: u64 to (i1 & 0xFF)
  set n6: u64 to (i1 | 0xFF)
  set n7: u64 to (i1 ^ 0xFF)
  set n8: u64 to (i1 shl 2)
  set n9: u64 to (i1 shr 1)
  set n10: u64 to (i1 sar 1)

  // --- address computations are pointer-like (p64) ---
  // addr(base, index, scale, disp) => p64
  set addr0: p64 to addr(4096, 4, 8, 16)

  // load/store type names (parser maps these to RANE_TYPE_*)
  // load(Ty, addrExpr) => Ty
  set v_u8: u8 to load(u8, addr0)
  set v_u16: u16 to load(u16, addr0)
  set v_u32: u32 to load(u32, addr0)
  set v_u64: u64 to load(u64, addr0)

  set v_i8: i8 to load(i8, addr0)
  set v_i16: i16 to load(i16, addr0)
  set v_i32: i32 to load(i32, addr0)
  set v_i64: i64 to load(i64, addr0)

  set v_p: p64 to load(p64, addr0)
  set v_b: b1 to load(b1, addr0)

  // store(Ty, addrExpr, valueExpr) => Ty (returns stored value)
  // NOTE: the typechecker requires `valueExpr` type == Ty exactly.
  set st_u32: u32 to store(u32, addr0, 7)
  set st_u64: u64 to store(u64, addr0, i1)
  set st_b1: b1 to store(b1, addr0, c0)

  // --- v1 user-defined struct literals (named fields) ---
  set h: Header to Header{
    magic: 0x52414E45
    version: 1
    flags: 0
    size: 4096
  }

  // Member access is currently typed as u64 placeholder in the typechecker.
  // Still useful for demonstrating the surface.
  set hm: u64 to h.magic

  // v1 set into member (targetExpr)
  set h.version to 2

  // v1 add statement (numeric update)
  add h.size by 512

  say "struct surface ok"
  halt
end

start at node main
