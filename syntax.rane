// syntax.rane
// Exhaustive syntax-coverage sheet (ACTUAL RANE SOURCE)
// Targets what your bootstrap parser already accepts, and keeps future tokens scaffolded.

///////////////////////////////////////////////////////////////////////////
// 0) Reserved / tokenized keywords (NOT necessarily parseable today)
// Source of truth: rane_lexer.cpp identifier_type()
///////////////////////////////////////////////////////////////////////////
//
// let if then else while do for break continue return ret
// proc def call
// import export include exclude
// decide case default
// jump goto mark label
// guard zone hot cold deterministic repeat unroll
// not and or xor shl shr sar
// try catch throw
// define ifdef ifndef pragma namespace enum struct class public private protected
// static inline extern virtual const volatile constexpr consteval constinit
// new del cast type typealias alias mut immutable mutable null match pattern lambda
// handle target splice split difference increment decrement dedicate mutex ignore bypass
// isolate separate join declaration compile score sys admin plot peak point reg exception
// align mutate string literal linear nonlinear primitives tuples member open close
//
// NOTE: Only a subset is accepted at statement position by the current parser.

///////////////////////////////////////////////////////////////////////////
// 1) Imports (known-working older form)
///////////////////////////////////////////////////////////////////////////

import rane_rt_print;

///////////////////////////////////////////////////////////////////////////
// 2) MMIO region decl + read32/write32
///////////////////////////////////////////////////////////////////////////

mmio region REG from 4096 size 256;

///////////////////////////////////////////////////////////////////////////
// 3) Proc definitions (core surface)
///////////////////////////////////////////////////////////////////////////

proc add5(a, b, c, d, e) {
  return a + b + c + d + e;
}

proc identity(x) {
  return x;
}

///////////////////////////////////////////////////////////////////////////
// 4) Main proc exercises expressions + statements
///////////////////////////////////////////////////////////////////////////

proc main() {
  // 4.1) let bindings
  let a = 1;
  let b = 2;

  // 4.2) literals
  let i_dec = 123;
  let i_underscore = 1_000_000;
  let i_hex = 0xCAFE_BABE;
  let i_bin = 0b1010_0101;

  let t = true;
  let f = false;

  let s0 = "hello";
  let s1 = "with \\n escape";
  let n = null;

  // 4.3) unary
  let u0 = -i_dec;
  let u1 = not f;
  let u2 = !f;
  let u3 = ~i_dec;

  // 4.4) binary arithmetic / bitwise / shifts
  let ar0 = a + b;
  let ar1 = a - b;
  let ar2 = a * b;
  let ar3 = 100 / b;
  let ar4 = 100 % b;

  let bw0 = a & b;
  let bw1 = a | b;
  let bw2 = a ^ b;

  // word-form bitwise
  let bw3 = a xor b;

  // shifts: word and symbol forms
  let sh0 = i_dec shl 2;
  let sh1 = i_dec shr 1;
  let sh2 = i_dec sar 1;
  let sh3 = i_dec << 1;
  let sh4 = i_dec >> 1;

  // 4.5) comparisons (bootstrap bool: 0/1)
  let c0 = a < b;
  let c1 = a <= b;
  let c2 = a > b;
  let c3 = a >= b;
  let c4 = a == b;
  let c5 = a != b;

  // v1 compatibility: single '=' treated as equality in expr parsing
  let c6 = a = b;

  // 4.6) logical ops (short-circuit)
  let l0 = c0 and c5;
  let l1 = c0 or c4;
  let l2 = c0 && c5;
  let l3 = c0 || c4;

  // 4.7) ternary
  let te0 = c0 ? a : b;
  let te1 = (a < b) ? (a + 1) : (b + 1);

  // 4.8) choose max/min
  let ch0 = choose max(a, b);
  let ch1 = choose min(a, b);

  // 4.9) addr / load / store expression forms
  let p0 = addr(4096, 4, 8, 16);
  let y0 = load(u32, addr(4096, 0, 1, 0));
  let z0 = store(u32, addr(4096, 0, 1, 8), 7);

  // 4.10) mmio sugar statements
  let x = 0;
  read32 REG, 0 into x;
  write32 REG, 4, 123;

  // 4.11) ident literal
  let sym0 = #rane_rt_print;
  let sym1 = #REG;

  // 4.12) calls (expression calls)
  let sum = add5(1, 2, 3, 4, 5);
  let idv = identity(sum);

  // print is builtin lowered from EXPR_CALL named "print"
  print(s0);
  print(sum);
  print(idv);

  // 4.13) statement-form call + goto (bootstrap control flow)
  call identity(123) into slot 1;

  // conditional goto: goto <expr> -> <true_label>, <false_label>;
  goto (a < b) -> L_true, L_false;

label L_false;
  trap 7;
  goto 1 -> L_end, L_end;

label L_true;
  trap;

label L_end;
  halt;

  // unreachable; kept for AST coverage
  return 0;
}

///////////////////////////////////////////////////////////////////////////
// 5) v1 node/prose surface + v1 struct surface (parse-only coverage)
///////////////////////////////////////////////////////////////////////////

module demo_struct

struct Header:
  magic: u32
  version: u16
  flags: u16
  size: u64
end

node start:
  set h: Header to Header{
    magic: 0x52414E45
    version: 1
    flags: 0
    size: 4096
  }

  set m: u32 to h.magic

  set h.version to 2
  add h.size by 512

  say "ok"

  go to node end_node

  halt
end

node end_node:
  say "goodbye"
  halt
end

start at node start

///////////////////////////////////////////////////////////////////////////
// 6) Additional syntax coverage (only keep what your parser supports today)
//    (If unsupported, comment out locally until implemented.)
///////////////////////////////////////////////////////////////////////////

// proc loop_example() {
//   let i = 0;
//   while i < 10 {
//     print(i);
//     i = i + 1;
//   }
//   return i;
// }
//
// proc cond_example(x) {
//   if x > 0 {
//     print("positive");
//   } else {
//     print("non-positive");
//   }
//   return 0;
// }
//
// proc for_example() {
//   for let j = 0; j < 5; j = j + 1 {
//     print(j);
//   }
//   return 0;
// }
//
// proc nested_call_example(a, b) {
//   return add5(a, b, identity(a), add5(1, 2, 3, 4, 5), 0);
// }
//
// proc match_example(val) {
//   match val {
//     case 0: print("zero");
//     case 1: print("one");
//     default: print("other");
//   }
//   return 0;
// }
//
// proc lambda_example() {
//   let f = lambda(x) { return x + 1; };
//   let y = f(10);
//   print(y);
//   return y;
// }
//
// typealias word = u32;
// alias int32 = i32;
//
// const PI = 3.14159;
// constexpr E = 2.71828;
// constinit ZERO = 0;
//
// enum Color {
//   Red,
//   Green,
//   Blue
// }
//
// proc try_catch_example() {
//   try {
//     throw 42;
//   } catch (e) {
//     print(e);
//   }
//   return 0;
// }
