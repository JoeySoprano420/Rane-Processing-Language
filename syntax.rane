// syntax.rane
// Exhaustive syntax-coverage sheet (ACTUAL RANE SOURCE)
// Targets what your bootstrap parser already accepts, and keeps future tokens scaffolded.

///////////////////////////////////////////////////////////////////////////
// 0) Reserved / tokenized keywords (NOT necessarily parseable today)
// Source of truth: rane_lexer.cpp identifier_type()
///////////////////////////////////////////////////////////////////////////
//
// let if then else while do for break continue return ret
// proc def call
// import export include exclude
// decide case default
// jump goto mark label
// guard zone hot cold deterministic repeat unroll
// not and or xor shl shr sar
// try catch throw
// define ifdef ifndef pragma namespace enum struct class public private protected
// static inline extern virtual const volatile constexpr consteval constinit
// new del cast type typealias alias mut immutable mutable null match pattern lambda
// handle target splice split difference increment decrement dedicate mutex ignore bypass
// isolate separate join declaration compile score sys admin plot peak point reg exception
// align mutate string literal linear nonlinear primitives tuples member open close
//
// NOTE: Only a subset is accepted at statement position by the current parser.

///////////////////////////////////////////////////////////////////////////
// 1) Imports (known-working older form)
///////////////////////////////////////////////////////////////////////////

import rane_rt_print;

///////////////////////////////////////////////////////////////////////////
// 2) MMIO region decl + read32/write32
///////////////////////////////////////////////////////////////////////////

mmio region REG from 4096 size 256;

///////////////////////////////////////////////////////////////////////////
// 3) Proc definitions (core surface)
///////////////////////////////////////////////////////////////////////////

proc add5(a, b, c, d, e) {
  return a + b + c + d + e;
}

proc identity(x) {
  return x;
}

///////////////////////////////////////////////////////////////////////////
// 4) Main proc exercises expressions + statements
///////////////////////////////////////////////////////////////////////////

proc main() {
  // 4.1) let bindings
  let a = 1;
  let b = 2;

  // 4.2) literals
  let i_dec = 123;
  let i_underscore = 1_000_000;
  let i_hex = 0xCAFE_BABE;
  let i_bin = 0b1010_0101;

  let t = true;
  let f = false;

  let s0 = "hello";
  let s1 = "with \\n escape";
  let n = null;

  // 4.3) unary
  let u0 = -i_dec;
  let u1 = not f;
  let u2 = !f;
  let u3 = ~i_dec;

  // 4.4) binary arithmetic / bitwise / shifts
  let ar0 = a + b;
  let ar1 = a - b;
  let ar2 = a * b;
  let ar3 = 100 / b;
  let ar4 = 100 % b;

  let bw0 = a & b;
  let bw1 = a | b;
  let bw2 = a ^ b;

  // word-form bitwise
  let bw3 = a xor b;

  // shifts: word and symbol forms
  let sh0 = i_dec shl 2;
  let sh1 = i_dec shr 1;
  let sh2 = i_dec sar 1;
  let sh3 = i_dec << 1;
  let sh4 = i_dec >> 1;

  // 4.5) comparisons (bootstrap bool: 0/1)
  let c0 = a < b;
  let c1 = a <= b;
  let c2 = a > b;
  let c3 = a >= b;
  let c4 = a == b;
  let c5 = a != b;

  // v1 compatibility: single '=' treated as equality in expr parsing
  let c6 = a = b;

  // 4.6) logical ops (short-circuit)
  let l0 = c0 and c5;
  let l1 = c0 or c4;
  let l2 = c0 && c5;
  let l3 = c0 || c4;

  // 4.7) ternary
  let te0 = c0 ? a : b;
  let te1 = (a < b) ? (a + 1) : (b + 1);

  // 4.8) choose max/min
  let ch0 = choose max(a, b);
  let ch1 = choose min(a, b);

  // 4.9) addr / load / store expression forms
  let p0 = addr(4096, 4, 8, 16);
  let y0 = load(u32, addr(4096, 0, 1, 0));
  let z0 = store(u32, addr(4096, 0, 1, 8), 7);

  // 4.10) mmio sugar statements
  let x = 0;
  read32 REG, 0 into x;
  write32 REG, 4, 123;

  // 4.11) ident literal
  let sym0 = #rane_rt_print;
  let sym1 = #REG;

  // 4.12) calls (expression calls)
  let sum = add5(1, 2, 3, 4, 5);
  let idv = identity(sum);

  // print is builtin lowered from EXPR_CALL named "print"
  print(s0);
  print(sum);
  print(idv);

  // 4.13) statement-form call + goto (bootstrap control flow)
  call identity(123) into slot 1;

  // conditional goto: goto <expr> -> <true_label>, <false_label>;
  goto (a < b) -> L_true, L_false;

label L_false;
  trap 7;
  goto 1 -> L_end, L_end;

label L_true;
  trap;

label L_end;
  halt;

  // unreachable; kept for AST coverage
  return 0;
}

///////////////////////////////////////////////////////////////////////////
// 5) v1 node/prose surface + v1 struct surface (parse-only coverage)
///////////////////////////////////////////////////////////////////////////

module demo_struct

struct Header:
  magic: u32
  version: u16
  flags: u16
  size: u64
end

node start:
  set h: Header to Header{
    magic: 0x52414E45
    version: 1
    flags: 0
    size: 4096
  }

  set m: u32 to h.magic

  set h.version to 2
  add h.size by 512

  say "ok"

  go to node end_node

  halt
end

node end_node:
  say "goodbye"
  halt
end

start at node start

///////////////////////////////////////////////////////////////////////////
// 6) Additional syntax coverage (only keep what your parser supports today)
//    (If unsupported, comment out locally until implemented.)
///////////////////////////////////////////////////////////////////////////

// proc loop_example() {
//   let i = 0;
//   while i < 10 {
//     print(i);
//     i = i + 1;
//   }
//   return i;
// }
//
// proc cond_example(x) {
//   if x > 0 {
//     print("positive");
//   } else {
//     print("non-positive");
//   }
//   return 0;
// }
//
// proc for_example() {
//   for let j = 0; j < 5; j = j + 1 {
//     print(j);
//   }
//   return 0;
// }
//
// proc nested_call_example(a, b) {
//   return add5(a, b, identity(a), add5(1, 2, 3, 4, 5), 0);
// }
//
// proc match_example(val) {
//   match val {
//     case 0: print("zero");
//     case 1: print("one");
//     default: print("other");
//   }
//   return 0;
// }
//
// proc lambda_example() {
//   let f = lambda(x) { return x + 1; };
//   let y = f(10);
//   print(y);
//   return y;
// }
//
// typealias word = u32;
// alias int32 = i32;
//
// const PI = 3.14159;
// constexpr E = 2.71828;
// constinit ZERO = 0;
//
// enum Color {
//   Red,
//   Green,
//   Blue
// }
//
// proc try_catch_example() {
//   try {
//     throw 42;
//   } catch (e) {
//     print(e);
//   }
//   return 0;
// }
// syntax.rane
// Exhaustive syntax-coverage sheet (ACTUAL RANE SOURCE)
// Targets what your bootstrap parser already accepts, and keeps future tokens scaffolded.

///////////////////////////////////////////////////////////////////////////
// 0) Reserved / tokenized keywords (NOT necessarily parseable today)
// Source of truth: rane_lexer.cpp identifier_type()
///////////////////////////////////////////////////////////////////////////
//
// let if then else while do for break continue return ret
// proc def call
// import export include exclude
// decide case default
// jump goto mark label
// guard zone hot cold deterministic repeat unroll
// not and or xor shl shr sar
// try catch throw
// define ifdef ifndef pragma namespace enum struct class public private protected
// static inline extern virtual const volatile constexpr consteval constinit
// new del cast type typealias alias mut immutable mutable null match pattern lambda
// handle target splice split difference increment decrement dedicate mutex ignore bypass
// isolate separate join declaration compile score sys admin plot peak point reg exception
// align mutate string literal linear nonlinear primitives tuples member open close
//
// NOTE: Only a subset is accepted at statement position by the current parser.

///////////////////////////////////////////////////////////////////////////
// 1) Imports (known-working older form)
///////////////////////////////////////////////////////////////////////////

import rane_rt_print;

///////////////////////////////////////////////////////////////////////////
// 2) MMIO region decl + read32/write32
///////////////////////////////////////////////////////////////////////////

mmio region REG from 4096 size 256;

///////////////////////////////////////////////////////////////////////////
// 3) Proc definitions (core surface)
///////////////////////////////////////////////////////////////////////////

proc add5(a, b, c, d, e) {
  return a + b + c + d + e;
}

proc identity(x) {
  return x;
}

///////////////////////////////////////////////////////////////////////////
// 4) Main proc exercises expressions + statements
///////////////////////////////////////////////////////////////////////////

proc main() {
  // 4.1) let bindings
  let a = 1;
  let b = 2;

  // 4.2) literals
  let i_dec = 123;
  let i_underscore = 1_000_000;
  let i_hex = 0xCAFE_BABE;
  let i_bin = 0b1010_0101;

  let t = true;
  let f = false;

  let s0 = "hello";
  let s1 = "with \\n escape";
  let n = null;

  // 4.3) unary
  let u0 = -i_dec;
  let u1 = not f;
  let u2 = !f;
  let u3 = ~i_dec;

  // 4.4) binary arithmetic / bitwise / shifts
  let ar0 = a + b;
  let ar1 = a - b;
  let ar2 = a * b;
  let ar3 = 100 / b;
  let ar4 = 100 % b;

  let bw0 = a & b;
  let bw1 = a | b;
  let bw2 = a ^ b;

  // word-form bitwise
  let bw3 = a xor b;

  // shifts: word and symbol forms
  let sh0 = i_dec shl 2;
  let sh1 = i_dec shr 1;
  let sh2 = i_dec sar 1;
  let sh3 = i_dec << 1;
  let sh4 = i_dec >> 1;

  // 4.5) comparisons (bootstrap bool: 0/1)
  let c0 = a < b;
  let c1 = a <= b;
  let c2 = a > b;
  let c3 = a >= b;
  let c4 = a == b;
  let c5 = a != b;

  // v1 compatibility: single '=' treated as equality in expr parsing
  let c6 = a = b;

  // 4.6) logical ops (short-circuit)
  let l0 = c0 and c5;
  let l1 = c0 or c4;
  let l2 = c0 && c5;
  let l3 = c0 || c4;

  // 4.7) ternary
  let te0 = c0 ? a : b;
  let te1 = (a < b) ? (a + 1) : (b + 1);

  // 4.8) choose max/min
  let ch0 = choose max(a, b);
  let ch1 = choose min(a, b);

  // 4.9) addr / load / store expression forms
  let p0 = addr(4096, 4, 8, 16);
  let y0 = load(u32, addr(4096, 0, 1, 0));
  let z0 = store(u32, addr(4096, 0, 1, 8), 7);

  // 4.10) mmio sugar statements
  let x = 0;
  read32 REG, 0 into x;
  write32 REG, 4, 123;

  // 4.11) ident literal
  let sym0 = #rane_rt_print;
  let sym1 = #REG;

  // 4.12) calls (expression calls)
  let sum = add5(1, 2, 3, 4, 5);
  let idv = identity(sum);

  // print is builtin lowered from EXPR_CALL named "print"
  print(s0);
  print(sum);
  print(idv);

  // 4.13) statement-form call + goto (bootstrap control flow)
  call identity(123) into slot 1;

  // conditional goto: goto <expr> -> <true_label>, <false_label>;
  goto (a < b) -> L_true, L_false;

label L_false;
  trap 7;
  goto 1 -> L_end, L_end;

label L_true;
  trap;

label L_end;
  halt;

  // unreachable; kept for AST coverage
  return 0;
}

///////////////////////////////////////////////////////////////////////////
// 5) v1 node/prose surface + v1 struct surface (parse-only coverage)
///////////////////////////////////////////////////////////////////////////

module demo_struct

struct Header:
  magic: u32
  version: u16
  flags: u16
  size: u64
end

node start:
  set h: Header to Header{
    magic: 0x52414E45
    version: 1
    flags: 0
    size: 4096
  }

  set m: u32 to h.magic

  set h.version to 2
  add h.size by 512

  say "ok"

  go to node end_node

  halt
end

node end_node:
  say "goodbye"
  halt
end

start at node start

///////////////////////////////////////////////////////////////////////////
// 6) Additional syntax coverage (only keep what your parser supports today)
//    (If unsupported, comment out locally until implemented.)
///////////////////////////////////////////////////////////////////////////

// proc loop_example() {
//   let i = 0;
//   while i < 10 {
//     print(i);
//     i = i + 1;
//   }
//   return i;
// }
//
// proc cond_example(x) {
//   if x > 0 {
//     print("positive");
//   } else {
//     print("non-positive");
//   }
//   return 0;
// }
//
// proc for_example() {
//   for let j = 0; j < 5; j = j + 1 {
//     print(j);
//   }
//   return 0;
// }
//
// proc nested_call_example(a, b) {
//   return add5(a, b, identity(a), add5(1, 2, 3, 4, 5), 0);
// }
//
// proc match_example(val) {
//   match val {
//     case 0: print("zero");
//     case 1: print("one");
//     default: print("other");
//   }
//   return 0;
// }
//
// proc lambda_example() {
//   let f = lambda(x) { return x + 1; };
//   let y = f(10);
//   print(y);
//   return y;
// }
//
// typealias word = u32;
// alias int32 = i32;
//
// const PI = 3.14159;
// constexpr E = 2.71828;
// constinit ZERO = 0;
//
// enum Color {
//   Red,
//   Green,
//   Blue
// }
//
// proc try_catch_example() {
//   try {
//     throw 42;
//   } catch (e) {
//     print(e);
//   }
//   return 0;
// }

///////////////////////////////////////////////////////////////////////////
// 7) Extended feature scaffold (NEW: exhaustive list + usage samples)
//    - Preserve everything above. This section adds sugar-heavy primitives,
//      CIAMS helpers, additional types, privileges, and many constructs the
//      compiler scaffold may accept in future.
//    - Keep these as a coverage sheet / examples; comment parts if not parseable.
///////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
// 7.1) New types and widths, numeric forms
///////////////////////////////////////////////////////////////////////////

// integer widths
// 8-bit 16-bit 32-bit 64-bit 128-bit 512-bit
// signed/unsigned: i8,i16,i32,i64,i128, i512 ; u8,u16,u32,u64,u128,u512
// floating: f32,f64,f128
// fractional / rational primitives; numeric sequences (fibonacci)
type i128
type u128
type i512
type u512
type f128

// numeral examples
let n8: i8 = 127;
let n16: i16 = 32767;
let n128: i128 = 0x1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0;
let n512: u512 = 0; // placeholder

///////////////////////////////////////////////////////////////////////////
// 7.2) Collections, containers, tuples, arrays, vectors, tables
///////////////////////////////////////////////////////////////////////////

// array/slice/vector/table/list/container examples
let arr = [1, 2, 3, 4, 5];
let vec = vector(1, 2, 3);
let table = map("a" -> 1, "b" -> 2);
let mat = [[1,2],[3,4]];

let tup = (1, "hi", true);
let (x0, x1, x2) = tup;

///////////////////////////////////////////////////////////////////////////
// 7.3) Modules, namespaces, import/export, visibility
///////////////////////////////////////////////////////////////////////////

namespace math {
  export proc square(x) { return x * x; }
  private proc hidden() { return 0; }
}
import math::square;
export proc exported_fn() { return 7; }

///////////////////////////////////////////////////////////////////////////
// 7.4) Privileges, permissions, admin, sys, and security specifiers
///////////////////////////////////////////////////////////////////////////

// privileges / permission qualifiers
admin proc admin_fn() { return 0; }
protected proc prot_fn() { return 1; }
public proc pub_fn() { return 2; }
private proc priv_fn() { return 3; }

///////////////////////////////////////////////////////////////////////////
// 7.5) Memory model, allocation, ownership, borrow, linear types
///////////////////////////////////////////////////////////////////////////

// ownership and allocation primitives
let p = allocate(u8, 16); // malloc-like
mutate p[0] to 42;
free p;

linear proc lin_inc(x) { return x + 1; } // linear type example
nonlinear proc nlin_mul(x) { return x * 2; }

///////////////////////////////////////////////////////////////////////////
// 7.6) Concurrency: async/await, threads, mutex, channels, schedulers
///////////////////////////////////////////////////////////////////////////

async proc async_fetch() {
  let v = await fetch_data();
  return v;
}

dedicate proc spawn_worker() {
  spawn spawn_worker();
  join spawn_worker();
  return 0;
}

mutex m1;
lock(m1) {
  // critical section
}

channel<int> ch;
send(ch, 1);
let received = recv(ch);

///////////////////////////////////////////////////////////////////////////
// 7.7) CIAMS helpers and contextual macros (examples)
///////////////////////////////////////////////////////////////////////////

// CIAMS: contextual inference, resolves words into ops, rewrites ambiguous tokens,
// inserts implicit casts, and normalizes mutable/const contexts.
//
// Examples of CIAMS patterns (coverage):
//  - word ops to symbol ops (and -> &&, or -> ||, xor -> ^)
//  - treat single '=' as '==' inside expressions unless preceded by 'let'
//  - contextual overload resolution: choose max(a,b) -> intrinsics.choose_max(a,b)
//  - implicit casts: int -> f32 where required
//  - scope-driven default lifetimes (constinit -> compile-time init, consteval -> compile-time eval)
//
// CO-ANNOTATION:
// ciams: choose max(a,b) -> choose_max(a,b)
// ciams: when parsing 'let x = a = b;' preserve assignment semantics (not equality)
// ciams: when in 'expr' context, '=' -> '==' unless tokens indicate assignment

///////////////////////////////////////////////////////////////////////////
// 7.8) Control flow, patterns, match/case, switch, decide
///////////////////////////////////////////////////////////////////////////

proc switch_example(x) {
  switch x {
    case 0: print("zero");
    case 1: print("one");
    default: print("other");
  }
  return 0;
}

proc decide_example(x) {
  decide x {
    case 1: print("one");
    case 2: print("two");
    default: print("other");
  }
  return 0;
}

///////////////////////////////////////////////////////////////////////////
// 7.9) Advanced loops, unrolling, tail-call, loop hints, profiling
///////////////////////////////////////////////////////////////////////////

proc loop_unroll_example() {
  // hint: unroll 4
  #pragma unroll(4)
  for let i = 0; i < 16; i = i + 1 {
    print(i);
  }
  return 0;
}

proc tail_recursive(n, acc) {
  if n == 0 { return acc; }
  return tail_recursive(n - 1, acc + n); // eligible for tail call optimization
}

///////////////////////////////////////////////////////////////////////////
// 7.10) Optimizations / codegen hints
///////////////////////////////////////////////////////////////////////////

// profile-guided optimization example
#pragma profile("hot")
inline proc hot_add(a, b) { return a + b; }

// constant folding, dead code elimination hints (compiler may obey)
consteval proc const_fn() { return 42; }

///////////////////////////////////////////////////////////////////////////
// 7.11) Low-level assembly, registers, syscalls, and machine ops (coverage)
///////////////////////////////////////////////////////////////////////////

// inline assembly (coverage form)
proc asm_example() {
  asm {
    mov rax, 1
    add rax, 2
  }
  return 0;
}

// register names as identifiers and explicit registers (coverage)
let _rax = rax;
let _rcx = rcx;
let _rdx = rdx;
let _rsi = rsi;
let _rdi = rdi;
let _rbp = rbp;
let _rsp = rsp;
let _r8  = r8;
let _r9  = r9;
let _r10 = r10;
let _r11 = r11;
let _r12 = r12;
let _r13 = r13;
let _r14 = r14;
let _r15 = r15;

///////////////////////////////////////////////////////////////////////////
// 7.12) Exception handling, try/catch/finally/throw/trap semantics
///////////////////////////////////////////////////////////////////////////

proc try_example() {
  try {
    throw 100;
  } catch (e) {
    print(e);
  } finally {
    print("done");
  }
  return 0;
}

///////////////////////////////////////////////////////////////////////////
// 7.13) Metaprogramming: macros, templates, generics, reflection
///////////////////////////////////////////////////////////////////////////

// simple macro and templating
macro SQUARE(x) = (x) * (x)
template <T>
proc generic_id(x: T) { return x; }

///////////////////////////////////////////////////////////////////////////
// 7.14) Structs, classes, records, unions, variants, attributes
///////////////////////////////////////////////////////////////////////////

struct Point:
  x: i32
  y: i32
end

@derive(Eq, Ord, Debug)
struct Person:
  name: string
  age: u8
end

union IntOrFloat {
  i: i32
  f: f32
}

variant Maybe<T> = Some(T) | None

///////////////////////////////////////////////////////////////////////////
// 7.15) I/O, file ops, with/using, resource management, defer
///////////////////////////////////////////////////////////////////////////

proc file_read_example() {
  with open("file.txt") as f {
    let s = f.read();
    print(s);
  }
  return 0;
}

proc defer_example() {
  let f = open("file.txt");
  defer { close(f); }
  print("done");
  return 0;
}

///////////////////////////////////////////////////////////////////////////
// 7.16) Scheduling, async pipelines, channels, parallelism
///////////////////////////////////////////////////////////////////////////

proc pipeline_example() {
  let result = [1,2,3]
    |> map(x => x * 2)
    |> filter(x => x > 2)
    |> reduce((a,b) => a + b, 0);
  print(result);
  return result;
}

///////////////////////////////////////////////////////////////////////////
// 7.17) Diagnostics, contracts, assertions, proofs and verification hints
///////////////////////////////////////////////////////////////////////////

contract positive(x) { ensures(x > 0); }

proc assert_example(x) {
  assert(x != 0, "x must be non-zero");
  return x;
}

///////////////////////////////////////////////////////////////////////////
// 7.18) Debug, profile, admin, system and build pragmas
///////////////////////////////////////////////////////////////////////////

pragma("optimize", "speed");
pragma("lto", "on");
pragma("scheduling", "fair");
define BUILD_ID 0xDEADBEEF

///////////////////////////////////////////////////////////////////////////
// 7.19) Full keyword/identifier coverage list (expanded)
//   (keeps appearance in the syntax sheet so lexers/parsers may reserve tokens)
//
let if then else elif while do for break continue return proc def call import export include exclude
decide case default jump goto mark label guard zone hot cold repeat unroll not and or xor shl shr sar
try catch throw define ifdef ifndef pragma namespace enum struct class public private protected
static inline extern virtual const volatile constexpr consteval constinit new del cast type typealias alias
mut immutable mutable null match pattern lambda handle target splice split difference increment decrement
dedicate mutex ignore bypass isolate separate join declaration compile score sys admin plot peak point reg exception
align mutate string literal linear nonlinear primitives tuples member open close module node start set to add by say go halt
mmio region read32 write32 trap halt import rane_rt_print choose addr load store print vector map channel spawn join lock with using defer
macro template generic const consteval constinit inline asm syscall tailcall unroll profile pragma optimize lto

///////////////////////////////////////////////////////////////////////////
// 7.20) End-to-end synthetic examples (coverage; some forms are illustrative)
///////////////////////////////////////////////////////////////////////////

// vector math example
proc vec_add(a, b) {
  let v = vector(a.x + b.x, a.y + b.y, a.z + b.z);
  return v;
}

// scheduler + async example
async proc scheduled_work() {
  let r1 = await async_fetch();
  let r2 = await async_fetch();
  print(r1 + r2);
  return r1 + r2;
}

// ownership + borrow example
proc ownership_example() {
  let p = allocate(i32, 4);
  mutate p[0] to 10;
  let q = borrow p; // borrow semantics (coverage)
  print(q[0]);
  free p;
  return 0;
}

///////////////////////////////////////////////////////////////////////////
// NOTE:
// - This file is intended as a maximal, evolving coverage sheet. The parser,
//   CIAMS pass, lexer, typechecker and codegen should treat lines here as
//   authoritative examples and reserved tokens. Keep adding forms as the
//   implementation expands. When a form is implemented, turn the example
//   into a test that the compiler validates/lowers correctly.
//
// - Preserve all examples (do not remove). If you extend the language, add
//   new examples here under a new subsection.
//
// - CIAMS is a first-class pass: implement rewrites, contextual resolution,
//   operator normalization, implicit casts, and other heuristics to make the
//   surface ergonomic while keeping the IR and codegen simple and deterministic.

///////////////////////////////////////////////////////////////////////////
// 8) Additions: eval, enum usage examples, and comment forms (ADDED)
// - These are appended to preserve everything above while adding requested
//   features: `eval` operator, explicit `enum` examples and comment forms.
///////////////////////////////////////////////////////////////////////////

// 8.1) eval: runtime evaluation / dynamic evaluation (coverage)
// - `eval` runs a string as code in a dynamic context (coverage form).
// - CIAMS and typechecker should flag usage where dynamic evaluation is unsafe.
// - Example usages:
let d1 = eval("1 + 2");
let d2 = eval("let x = 3; x * 2");
eval("print(\"runtime-eval\")");

proc eval_example(x) {
  // eval within a procedure (returns dynamic / i64 for coverage)
  let res = eval("10 + " + x); // string concat then eval (coverage)
  print(res);
  return res;
}

// 8.2) enum: expanded examples and typed enums (coverage)
// - `enum` already appears earlier; show typed enums and pattern usage.
enum Flags : u8 {
  None = 0,
  Read = 1,
  Write = 2,
  Exec = 4,
  ReadWrite = Read | Write
}

enum Color : i32 {
  Red = 0,
  Green = 1,
  Blue = 2
}

proc enum_usage() {
  let f = Flags.Read | Flags.Write;
  if (f & Flags.Write) {
    print("writable");
  }
  let c = Color.Green;
  print(c);
  return 0;
}

// 8.3) Comments: single-line, block, doc comments, and nested block comment examples
// single-line comment example (//) - already widely used above

/* block comment example:
   This is a multi-line block comment that can span multiple lines.
   It may contain code-like text without being parsed.
*/

/* nested block comment start
   /* inner block */
   nested block end */

/// doc comment example for a proc
/// This proc demonstrates doc comments recognized by tools.
proc doc_comment_example() {
  // Implementation stub (coverage)
  return 0;
}

// 8.4) CIAMS notes related to eval and comment handling
// - CIAMS should:
//   * normalize `eval` use: mark as dynamic and require explicit opt-in (e.g., `unsafe eval(...)`)
//   * preserve comments during parsing where helpful for tooling (doc comments)
//   * ensure '=' rewrite heuristics do not convert assignment to equality within eval string contexts
//   * treat enums as first-class constant sets for typechecking and pattern matching

///////////////////////////////////////////////////////////////////////////
// 8.5) Add eval and comment tokens to coverage lists (do not remove prior entries)
// - This keeps lexer/reserved lists aware of the new tokens without altering
//   previously declared lines above.
let eval; // reserved appearance for lexer coverage
// comment tokens are lexical; ensure lexer supports //, /* ... */, /// doc

///////////////////////////////////////////////////////////////////////////
// End additions
///////////////////////////////////////////////////////////////////////////
