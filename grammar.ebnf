(*=============================================================================
  RANE (Updated) — Complete EBNF Grammar (sugar-rich / low-punctuation)
  As of 01_12_2026

  Goals:
    - Support BOTH classic braces/semicolons and modern block-verb forms.
    - Make: with / defer / lock / spawn / join / match single-word verbs.
    - Allow “colon blocks” (Python-like) and “brace blocks” interchangeably.
    - Keep the grammar unambiguous enough for a deterministic bootstrap parser.

  Notes:
    - EBNF uses:
        X?  optional
        X*  repetition
        X+  1+ repetition
        (A|B) alternatives
    - Newlines may terminate statements in “soft” mode.
    - Semicolons are optional if newline termination is enabled.
    - Indentation is NOT semantic in this grammar; blocks are explicit by { } or : ... end.

=============================================================================*)

(*---------------------------------------
  LEXICAL LAYER (tokens)
----------------------------------------*)

letter          = "A".."Z" | "a".."z" | "_" ;
digit           = "0".."9" ;
hexdigit        = digit | "A".."F" | "a".."f" ;

ident           = letter, { letter | digit } ;
path_ident      = ident, { "::", ident } ;
symbol_lit      = "#", ident ;                        (* #REG, #rane_rt_print *)
string_lit      = '"', { char | escape }, '"' ;
escape          = "\", ( "\" | '"' | "n" | "r" | "t" ) ;

int_dec         = ["-"], digit, { digit | "_" } ;
int_hex         = ["-"], "0x", hexdigit, { hexdigit | "_" } ;
int_bin         = ["-"], "0b", ("0"|"1"), { ("0"|"1") | "_" } ;
int_lit         = int_hex | int_bin | int_dec ;

float_lit       = ["-"], digit, { digit | "_" }, ".", digit, { digit | "_" },
                  [ ("e"|"E"), ["+"|"-"], digit, { digit | "_" } ] ;

bool_lit        = "true" | "false" ;
null_lit        = "null" ;

ws              = { " " | "\t" } ;
nl              = "\n" | "\r\n" ;

comment_line    = "//", { ? not-nl ? }, nl ;
comment_block   = "/*", { ? any ? }, "*/" ;

sep             = ( ";" | nl )+ ;                     (* statement separator *)
opt_sep         = ( ";" | nl )* ;

(*---------------------------------------
  TOP-LEVEL STRUCTURE
----------------------------------------*)

unit            = opt_sep, { top_item, opt_sep }, EOF ;

top_item        = import_decl
                | module_decl
                | namespace_decl
                | visibility_decl
                | type_decl
                | proc_decl
                | const_decl
                | pragma_decl
                | define_decl
                | mmio_decl
                | capability_decl
                | node_module_decl
                ;

(*---------------------------------------
  DIRECTIVES / MODULE SYSTEM
----------------------------------------*)

import_decl     = "import", ws, import_path, opt_sep ;
import_path     = path_ident ;

module_decl     = "module", ws, ident, opt_sep ;

namespace_decl  = "namespace", ws, ident, ws?, namespace_body ;
namespace_body  = block_like( { ns_item, opt_sep } ) ;

ns_item         = visibility_decl
                | type_decl
                | proc_decl
                | const_decl
                | import_decl
                | pragma_decl
                | define_decl
                | capability_decl
                | mmio_decl
                | node_module_decl
                ;

visibility_decl = ("public" | "private" | "protected" | "admin" | "export"),
                  ws, ( proc_decl | type_decl | const_decl ), opt_sep? ;

pragma_decl     = ("#pragma" | "pragma"), ws, pragma_payload, opt_sep ;
pragma_payload  = ident, [ "(", opt_ws_expr_list, ")" ]
                | "(", opt_ws_expr_list, ")"
                ;

define_decl     = "define", ws, ident, ws, const_expr, opt_sep ;

(*---------------------------------------
  CAPABILITIES / EFFECTS
----------------------------------------*)

capability_decl = "capability", ws, "(", ws?, cap_name, ws?, ")", opt_sep ;
cap_name        = ident ;

requires_clause = "requires", ws, "(", ws?, cap_list, ws?, ")"
                | "requires", ws, cap_list
                ;

cap_list        = cap_name, { ws?, ",", ws?, cap_name } ;

(*---------------------------------------
  MMIO
----------------------------------------*)

mmio_decl       = "mmio", ws, "region", ws, ident, ws,
                  "from", ws, const_expr, ws,
                  "size", ws, const_expr, opt_sep ;

(*---------------------------------------
  TYPES / DECLARATIONS
----------------------------------------*)

type_decl       = typealias_decl
                | alias_decl
                | primitive_decl
                | struct_decl
                | enum_decl
                | variant_decl
                | union_decl
                ;

primitive_decl  = "type", ws, ident, opt_sep ;        (* allows declaring builtins too *)

typealias_decl  = ("typealias" | "type_alias"), ws, ident, ws?, "=", ws?, type_ref, opt_sep ;
alias_decl      = "alias", ws, ident, ws?, "=", ws?, type_ref, opt_sep ;

const_decl      = ("const" | "constexpr" | "constinit"), ws,
                  ident, ws?, ":", ws?, type_ref, ws?, "=", ws?, const_expr, opt_sep
                | "consteval", ws, proc_decl          (* consteval proc *)
                ;

struct_decl     = struct_head, ws?, struct_body ;
struct_head     = "struct", ws, ident, [ generic_params ] ;
struct_body     = block_like( { struct_field, opt_sep } ) ;
struct_field    = ident, ws?, ":", ws?, type_ref, opt_sep? ;

enum_decl       = "enum", ws, ident, [ ws?, ":", ws?, type_ref ], ws?, enum_body ;
enum_body       = brace_block( { enum_member, opt_sep } )
                | block_like( { enum_member, opt_sep } )
                ;
enum_member     = ident, [ ws?, "=", ws?, const_expr ] ;

variant_decl    = ("variant" | "sum"), ws, ident, [ generic_params ],
                  ws?, "=", ws?, variant_alt, { ws?, "|", ws?, variant_alt }, opt_sep ;
variant_alt     = ident, [ ws?, "(", ws?, type_ref, ws?, ")" ] ;

union_decl      = "union", ws, ident, ws?, union_body ;
union_body      = block_like( { union_field, opt_sep } ) ;
union_field     = ident, ws?, ":", ws?, type_ref, opt_sep? ;

generic_params  = "<", ws?, ident, { ws?, ",", ws?, ident }, ws?, ">" ;

(*---------------------------------------
  PROCEDURES / FUNCTIONS
----------------------------------------*)

proc_decl       = proc_head, ws?, proc_body ;
proc_head       = proc_flavor?, ws?, "proc", ws, ident,
                  [ generic_params ],
                  ws?, "(", ws?, param_list?, ws?, ")",
                  ws?, "->", ws?, type_ref,
                  ( ws, requires_clause )?
                | proc_flavor?, ws?, "fn", ws, ident,
                  [ generic_params ],
                  ws?, "(", ws?, param_list?, ws?, ")",
                  ws?, "->", ws?, type_ref,
                  ( ws, requires_clause )?
                ;

proc_flavor     = "inline" | "static" | "dedicate" | "async" | "extern" ;

param_list      = param, { ws?, ",", ws?, param } ;
param           = ident, ws?, ":", ws?, type_ref ;

proc_body       = block_like( { stmt, opt_sep } ) ;

(*---------------------------------------
  TYPE REFERENCES
----------------------------------------*)

type_ref        = fn_type
                | ptr_type
                | array_type
                | generic_type
                | named_type
                ;

named_type      = path_ident ;
ptr_type        = "*", ws?, type_ref ;
array_type      = "[", ws?, const_expr, ws?, "]", ws?, type_ref ;
generic_type    = path_ident, ws?, "<", ws?, type_ref, { ws?, ",", ws?, type_ref }, ws?, ">" ;

fn_type         = "fn", ws?, "(", ws?, type_ref_list?, ws?, ")", ws?, "->", ws?, type_ref ;
type_ref_list   = type_ref, { ws?, ",", ws?, type_ref } ;

(*---------------------------------------
  STATEMENTS
----------------------------------------*)

stmt            = block_stmt
                | let_stmt
                | assign_stmt
                | mutate_stmt
                | add_by_stmt
                | if_stmt
                | while_stmt
                | for_stmt
                | return_stmt
                | try_stmt
                | throw_stmt
                | trap_stmt
                | halt_stmt
                | with_stmt
                | defer_stmt
                | lock_stmt
                | match_stmt
                | goto_stmt
                | label_stmt
                | expr_stmt
                ;

block_stmt      = block_like( { stmt, opt_sep } ) ;

let_stmt        = ("let" | "set"), ws, binding, ( ws, ("=" | "to"), ws, expr )? ;
binding         = ident, ( ws?, ":", ws?, type_ref )?
                | "(", ws?, binding, { ws?, ",", ws?, binding }, ws?, ")" ;

assign_stmt     = lvalue, ws?, ("=" | "to"), ws?, expr ;
mutate_stmt     = "mutate", ws, lvalue, ws, "to", ws, expr ;
add_by_stmt     = "add", ws, lvalue, ws, "by", ws, expr ;

expr_stmt       = expr ;                              (* calls, etc *)

if_stmt         = "if", ws, expr, ws?, then_part, [ ws?, else_part ] ;
then_part       = block_like( { stmt, opt_sep } )
                | stmt_single
                ;
else_part       = "else", ws?, ( block_like( { stmt, opt_sep } ) | stmt_single ) ;
stmt_single     = stmt ;                               (* for single-line if bodies *)

while_stmt      = "while", ws, expr, ws?, block_like( { stmt, opt_sep } ) ;

for_stmt        = "for", ws, for_header, ws?, block_like( { stmt, opt_sep } ) ;
for_header      = "let", ws, ident, ws?, ":", ws?, type_ref, ws?, "=", ws?, expr,
                  ws?, ";", ws?, expr, ws?, ";", ws?, expr
                | "let", ws, ident, ws, "in", ws, expr, ws?, "..", ws?, expr
                ;

return_stmt     = ("return" | "ret"), [ ws, expr ] ;
throw_stmt      = "throw", ws, expr ;

try_stmt        = "try", ws?, block_like( { stmt, opt_sep } ),
                  { ws?, catch_clause },
                  [ ws?, finally_clause ] ;
catch_clause    = "catch", ws?, "(", ws?, ident, ws?, ")", ws?, block_like( { stmt, opt_sep } ) ;
finally_clause  = "finally", ws?, block_like( { stmt, opt_sep } ) ;

trap_stmt       = "trap", [ ws, expr ] ;
halt_stmt       = "halt" ;

goto_stmt       = "goto", ws, goto_form ;
goto_form       = expr, ws?, "->", ws?, ident, ws?, ",", ws?, ident
                | "(", ws?, expr, ws?, ")", ws?, "->", ws?, ident, ws?, ",", ws?, ident
                ;

label_stmt      = "label", ws, ident ;

(*---------------------------------------
  SUGAR STATEMENTS (modern verbs)
----------------------------------------*)

with_stmt       = "with", ws, expr, [ ws, "as", ws, ident ], ws?, block_like( { stmt, opt_sep } ) ;

defer_stmt      = "defer", ws?, defer_body ;
defer_body      = block_like( { stmt, opt_sep } )
                | stmt_single
                ;

lock_stmt       = "lock", ws?, "(", ws?, expr, ws?, ")", ws?, block_like( { stmt, opt_sep } )
                | "lock", ws, expr, ws?, block_like( { stmt, opt_sep } ) ;

match_stmt      = "match", ws, expr, ws?, match_body ;
match_body      = block_like( { match_arm, opt_sep } )
                | brace_block( { match_arm, opt_sep } )
                ;
match_arm       = ("case", ws, pattern, [ ws, "if", ws, expr ], ws?, ":", ws?, arm_body)
                | ("default", [ ws, pattern ]?), ws?, ":", ws?, arm_body
                ;
arm_body        = block_like( { stmt, opt_sep } )
                | stmt_single
                ;

pattern         = "_" 
                | int_lit
                | ident                               (* bind *)
                | ident, ws?, "(", ws?, ident, ws?, ")" (* VariantCtor(binder) *)
                | ident, ws?, "(", ws?, "_", ws?, ")"   (* VariantCtor(_) *)
                ;

(*---------------------------------------
  EXPRESSIONS
----------------------------------------*)

expr            = assignment_expr ;

assignment_expr = ternary_expr, ( ws?, ("="), ws?, ternary_expr )? ;  (* optional shorthand in expr *)

ternary_expr    = logical_or_expr, ( ws?, "?", ws?, expr, ws?, ":", ws?, expr )? ;

logical_or_expr = logical_and_expr, { ws?, ( "or" | "||" ), ws?, logical_and_expr } ;
logical_and_expr= bitxor_expr,      { ws?, ( "and" | "&&" ), ws?, bitxor_expr } ;

bitxor_expr     = bitor_expr,       { ws?, ( "xor" | "^" ), ws?, bitor_expr } ;
bitor_expr      = bitand_expr,      { ws?, ( "|" ), ws?, bitand_expr } ;
bitand_expr     = equality_expr,    { ws?, ( "&" ), ws?, equality_expr } ;

equality_expr   = compare_expr, { ws?, ( "==" | "!=" ), ws?, compare_expr } ;
compare_expr    = shift_expr,   { ws?, ( "<" | "<=" | ">" | ">=" ), ws?, shift_expr } ;

shift_expr      = additive_expr, { ws?, ( "shl" | "shr" | "sar" | "<<" | ">>" ), ws?, additive_expr } ;

additive_expr   = mult_expr, { ws?, ( "+" | "-" ), ws?, mult_expr } ;
mult_expr       = unary_expr, { ws?, ( "*" | "/" | "%" ), ws?, unary_expr } ;

unary_expr      = ( "-" | "!" | "not" | "~" ), ws?, unary_expr
                | postfix_expr
                ;

postfix_expr    = primary_expr, { postfix_tail } ;

postfix_tail    = call_tail | field_tail | index_tail ;

call_tail       = ws?, "(", ws?, arg_list?, ws?, ")" ;
arg_list        = expr, { ws?, ",", ws?, expr } ;

field_tail      = ws?, ".", ws?, ident ;
index_tail      = ws?, "[", ws?, expr, ws?, "]" ;

primary_expr    = literal
                | symbol_lit
                | choose_expr
                | spawn_expr
                | join_expr
                | await_expr
                | cast_expr
                | "(" , ws?, expr, ws?, ")"
                | ident
                ;

literal         = int_lit | float_lit | string_lit | bool_lit | null_lit ;

choose_expr     = "choose", ws, ("max" | "min"), ws?, "(", ws?, expr, ws?, ",", ws?, expr, ws?, ")"
                | "choose", ws, ("max" | "min"), ws, expr, ws?, ",", ws?, expr
                ;

spawn_expr      = "spawn", ws, expr
                | "spawn", ws, ident, ws, arg_list               (* verb form, no parens *)
                ;

join_expr       = "join", ws, expr ;

await_expr      = "await", ws, expr ;

cast_expr       = expr, ws, "as", ws, type_ref ;

lvalue          = ident
                | primary_expr, { field_tail | index_tail } ;     (* restricted by semantic checks *)

(*---------------------------------------
  INLINE ASM (optional, classic punctuation supported)
----------------------------------------*)

(* Keep as a statement form; body is raw tokens until matching end marker. *)
asm_stmt        = "asm", ws?, asm_block ;
asm_block       = brace_block( { ? asm_tokens ? } )
                | ":" , { ? asm_tokens ? }, "end"
                ;

(*---------------------------------------
  NODE/PROSE MODULE (v1) — executable mini-language
----------------------------------------*)

node_module_decl = "module", ws, ident, opt_sep, { node_item, opt_sep } ;

node_item        = node_block_decl | node_start_decl ;

node_block_decl  = "node", ws, ident, ws?, ":", opt_sep,
                   { node_stmt, opt_sep },
                   "end"
                 ;

node_start_decl  = "start", ws, "at", ws, "node", ws, ident ;

node_stmt        = node_set_stmt
                 | node_add_stmt
                 | node_say_stmt
                 | node_go_stmt
                 | node_halt_stmt
                 | node_trap_stmt
                 ;

node_set_stmt    = "set", ws, ident, [ ws?, ":", ws?, type_ref ], ws, "to", ws, expr ;
node_add_stmt    = "add", ws, node_lvalue, ws, "by", ws, expr ;
node_say_stmt    = "say", ws, expr ;
node_go_stmt     = "go", ws, "to", ws, "node", ws, ident ;
node_halt_stmt   = "halt" ;
node_trap_stmt   = "trap", [ ws, expr ] ;

node_lvalue      = ident, { ws?, ".", ws?, ident | ws?, "[", ws?, expr, ws?, "]" } ;

(*---------------------------------------
  BLOCK FORMS (brace or colon-end)
----------------------------------------*)

brace_block(items) = "{", opt_sep, items, opt_sep, "}" ;

colon_end_block(items) =
  ":", opt_sep,
  items,
  opt_sep, "end" ;

block_like(items) =
  brace_block(items)
| colon_end_block(items)
;

opt_ws_expr_list = expr, { ws?, ",", ws?, expr } ;

(*---------------------------------------
  CONST EXPRESSIONS (subset)
----------------------------------------*)
const_expr       = expr ;  (* semantic restriction: must fold *)

(*---------------------------------------
  EOF
----------------------------------------*)
EOF              = ? end of input ? ;
