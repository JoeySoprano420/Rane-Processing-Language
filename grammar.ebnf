(*=============================================================================
  RANE — UPDATED COMPLETE EBNF GRAMMAR
  (fully covers: syntax_sugar.rane + syntax.ciam.rane)
  As of 01_12_2026

  Two surfaces, one grammar:
    1) SUGAR SURFACE (minimal punctuation, indentation + ":" + "end")
       - import rane_rt_print
       - proc square x i64 -> i64: ... end
       - struct Header: magic u32 ... end
       - with open path as f: ... end
       - defer close f
       - lock m1: ... end
       - spawn spawn_worker 100000
       - join th1
       - match val: case 0: ... default: ... end
       - node/prose: node start: set h Header to Header: ... end ...

    2) CANONICAL (CIAM-LOWERED) SURFACE (braces/semicolons/commas restored)
       - import rane_rt_print;
       - proc square(x: i64) -> i64 { ... }
       - enum Flags : u8 { ... }
       - capability(heap_alloc);
       - with open(path) as f { ... }
       - (and/or CIAM can lower with/defer/lock/spawn/join/match)

  Design rules for determinism:
    - Blocks are explicit: either { ... } or : ... end
    - Newlines can terminate statements in sugar; semicolons terminate in canonical
    - Parentheses and commas are optional in sugar for many constructs, but always
      accepted in canonical.
    - This grammar is intentionally permissive; the resolver/typechecker enforces
      constraints (e.g., lvalue requirements, const_expr folding, capability rules).

  EBNF conventions:
    X? optional, X* repeat, X+ repeat, (A|B) alternatives
=============================================================================*)

(*=============================================================================
  0) LEXICAL TOKENS
=============================================================================*)

letter          = "A".."Z" | "a".."z" | "_" ;
digit           = "0".."9" ;
hexdigit        = digit | "A".."F" | "a".."f" ;

ident           = letter, { letter | digit } ;
path_ident      = ident, { "::", ident } ;

(* literals *)
string_lit      = '"', { char | escape }, '"' ;
escape          = "\", ( "\" | '"' | "n" | "r" | "t" ) ;

int_dec         = ["-"], digit, { digit | "_" } ;
int_hex         = ["-"], "0x", hexdigit, { hexdigit | "_" } ;
int_bin         = ["-"], "0b", ("0"|"1"), { ("0"|"1") | "_" } ;
int_lit         = int_hex | int_bin | int_dec ;

float_lit       = ["-"],
                  ( digit, { digit | "_" }, ".", digit, { digit | "_" } ),
                  [ ("e"|"E"), ["+"|"-"], digit, { digit | "_" } ] ;

bool_lit        = "true" | "false" ;
null_lit        = "null" ;

symbol_lit      = "#", ident ;

(* punctuation *)
LP              = "(" ; RP = ")" ;
LB              = "{" ; RB = "}" ;
LS              = "[" ; RS = "]" ;
LT              = "<" ; GT = ">" ;
COMMA           = "," ;
COLON           = ":" ;
SEMI            = ";" ;
DOT             = "." ;
ARROW           = "->" ;
FATARROW        = "=>" ;   (* reserved *)
PIPE            = "|" ;
QMARK           = "?" ;

(* whitespace / separators *)
ws              = { " " | "\t" } ;
nl              = "\n" | "\r\n" ;

comment_line    = "//", { ? not-nl ? }, nl ;
comment_block   = "/*", { ? any ? }, "*/" ;

(* statement separators:
   - sugar: newline(s) or semicolon(s)
   - canonical: semicolon required but allow nl as whitespace *)
sep             = ( SEMI | nl )+ ;
opt_sep         = ( SEMI | nl )* ;

EOF             = ? end of input ? ;

(*=============================================================================
  1) TOP LEVEL
=============================================================================*)

unit            = opt_sep, { top_item, opt_sep }, EOF ;

top_item        = import_decl
                | module_decl
                | namespace_decl
                | visibility_item
                | type_decl
                | proc_decl
                | const_decl
                | pragma_decl
                | define_decl
                | mmio_decl
                | capability_decl
                | contract_decl
                | macro_decl
                | template_decl
                | global_var_decl
                | node_module_group
                ;

(*=============================================================================
  2) IMPORTS / MODULES / NAMESPACES / VISIBILITY
=============================================================================*)

import_decl     = "import", ws, import_path, (SEMI | nl | EOF) ;
import_path     = path_ident ;

module_decl     = "module", ws, ident, (SEMI | nl | EOF) ;

namespace_decl  = "namespace", ws, ident, ws?, block_like(ns_item_list) ;
ns_item_list    = { ns_item, opt_sep } ;

ns_item         = import_decl
                | visibility_item
                | type_decl
                | proc_decl
                | const_decl
                | pragma_decl
                | define_decl
                | mmio_decl
                | capability_decl
                | contract_decl
                | macro_decl
                | template_decl
                | global_var_decl
                | node_module_group
                ;

visibility_item = visibility_kw, ws, (proc_decl | type_decl | const_decl | global_var_decl) ;
visibility_kw   = "public" | "private" | "protected" | "admin" | "export" ;

(*=============================================================================
  3) TYPES
=============================================================================*)

type_decl       = primitive_decl
                | typealias_decl
                | alias_decl
                | struct_decl
                | enum_decl
                | variant_decl
                | union_decl
                ;

primitive_decl  = "type", ws, ident, (SEMI | nl | EOF) ;

typealias_decl  = ("typealias" | "type_alias"), ws, ident, ws?, "=", ws?, type_ref, (SEMI | nl | EOF) ;
alias_decl      = "alias", ws, ident, ws?, "=", ws?, type_ref, (SEMI | nl | EOF) ;

type_ref        = fn_type
                | ptr_type
                | array_type
                | generic_type
                | named_type
                ;

named_type      = path_ident ;

ptr_type        = "*", ws?, type_ref ;

array_type      = LS, ws?, const_expr, ws?, RS, ws?, type_ref
                | "[", ws?, const_expr, ws?, "]", ws?, type_ref ;

generic_type    = path_ident, ws?, generic_args ;

generic_args    = LT, ws?, type_ref, { ws?, COMMA?, ws?, type_ref }, ws?, GT ;

fn_type         = "fn", ws?, LP, ws?, type_ref_list?, ws?, RP, ws?, ARROW, ws?, type_ref ;
type_ref_list   = type_ref, { ws?, COMMA, ws?, type_ref } ;

(*=============================================================================
  4) CONSTS / CTFE
=============================================================================*)

const_decl      =
  ( "const" | "constexpr" | "constinit" ),
  ws, ident,
  ( ws, type_ref )?,                 (* sugar: const PI f64 = ... *)
  ( ws?, ":", ws?, type_ref )?,      (* canonical: const PI: f64 = ... *)
  ws?, "=", ws?, const_expr,
  (SEMI | nl | EOF)
|
  "consteval", ws, proc_decl
;

const_expr      = expr ;  (* semantic restriction: must fold *)

(*=============================================================================
  5) ATTRIBUTES
=============================================================================*)

attribute_list  = { attribute, opt_sep } ;
attribute       = "@", ident, ( ws?, attribute_args )? ;
attribute_args  =
    LP, ws?, attr_arg, { ws?, COMMA, ws?, attr_arg }, ws?, RP
  | ws, attr_arg, { ws, attr_arg }                  (* sugar: @derive Eq Ord Debug *)
  ;
attr_arg        = ident | string_lit | int_lit ;

(*=============================================================================
  6) STRUCT / ENUM / VARIANT / UNION
=============================================================================*)

struct_decl     = attribute_list?, "struct", ws, ident, ( ws?, generic_params )?, ws?,
                  block_like(struct_field_list) ;

struct_field_list = { struct_field, opt_sep } ;

struct_field    =
    ident, ws, type_ref, (SEMI | nl | opt_sep)?      (* sugar: name string *)
  | ident, ws?, ":", ws?, type_ref, (SEMI | nl | opt_sep)?  (* canonical-ish *)
  ;

enum_decl       = "enum", ws, ident, ( ws, type_ref )?, ( ws?, ":", ws?, type_ref )?, ws?,
                  block_like(enum_member_list) ;

enum_member_list = { enum_member, opt_sep } ;
enum_member      = ident, ( ws?, "=", ws?, const_expr )? ;

variant_decl    = "variant", ws, ident, ( ws?, generic_params )?, ws?, variant_body ;

variant_body    =
    (* sugar block *)
    block_like( variant_alt_list )
  |
    (* canonical single-line form: variant Maybe<T> = Some(T) | None *)
    ws?, "=", ws?, variant_alt_canon, { ws?, PIPE, ws?, variant_alt_canon }, (SEMI | nl | EOF)
  ;

variant_alt_list = { variant_alt_sugar, opt_sep } ;

variant_alt_sugar =
    ident, ( ws, type_ref )?                         (* Some T | None *)
  ;

variant_alt_canon =
    ident, ( ws?, LP, ws?, type_ref, ws?, RP )?
  ;

union_decl      = "union", ws, ident, ws?, block_like(union_field_list) ;
union_field_list= { union_field, opt_sep } ;
union_field     =
    ident, ws, type_ref                               (* sugar: i i32 *)
  | ident, ws?, ":", ws?, type_ref                    (* canonical *)
  ;

generic_params  =
    LT, ws?, ident, { ws?, COMMA, ws?, ident }, ws?, GT
  | ws, ident, { ws, ident }                          (* sugar: template T *)
  ;

(*=============================================================================
  7) CAPABILITIES / CONTRACTS / MACROS / TEMPLATES
=============================================================================*)

capability_decl =
    "capability", ws, ident, (SEMI | nl | EOF)        (* sugar: capability heap_alloc *)
  | "capability", ws?, LP, ws?, ident, ws?, RP, (SEMI | nl | EOF)  (* canonical *)
  ;

requires_clause =
    "requires", ws, cap_list
  | "requires", ws?, LP, ws?, cap_list, ws?, RP
  ;

cap_list        = ident, { ws?, COMMA?, ws?, ident } ;

contract_decl   =
  "contract", ws, ident, ws, param_sugar, ws?, block_like(contract_stmt_list)
  |
  "contract", ws, ident, ws?, LP, ws?, param_list?, ws?, RP, ws?, block_like(contract_stmt_list)
  ;

contract_stmt_list = { contract_stmt, opt_sep } ;
contract_stmt      =
    "ensures", ws, expr
  | "requires", ws, expr
  | "assert", ws, expr, ( ws, string_lit )?
  ;

macro_decl      =
    "macro", ws, ident, ws, macro_params_sugar?, ws?, "=", ws?, expr, (SEMI | nl | EOF)
  |
    "macro", ws, ident, ws?, LP, ws?, param_list?, ws?, RP, ws?, "=", ws?, expr, (SEMI | nl | EOF)
  ;

macro_params_sugar = ident, { ws, ident } ;

template_decl   =
    "template", ws, generic_params, opt_sep, proc_decl
  |
    "template", ws, LT, ws?, ident, { ws?, COMMA, ws?, ident }, ws?, GT, opt_sep, proc_decl
  ;

(*=============================================================================
  8) GLOBAL VARS / RUNTIME OBJECTS
=============================================================================*)

global_var_decl =
    "mutex", ws, ident, (SEMI | nl | EOF)
  | "channel", ws?, ( generic_args | LT, ws?, type_ref, ws?, GT ), ws, ident, (SEMI | nl | EOF)
  ;

(*=============================================================================
  9) PROCEDURES (SUGAR + CANONICAL)
=============================================================================*)

proc_decl       = attribute_list?, proc_head, ws?, block_like(stmt_list) ;

proc_head       =
  proc_prefix*, "proc", ws, ident,
  ( ws?, generic_params )?,
  ( ws, param_sugar_list )?,         (* sugar: proc f x i64 y i64 -> i64 *)
  ( ws?, LP, ws?, param_list?, ws?, RP )?, (* canonical: proc f(x: i64, y: i64) -> i64 *)
  ws?, ARROW, ws?, type_ref,
  ( ws, requires_clause )?
|
  proc_prefix*, "fn", ws, ident,
  ( ws?, generic_params )?,
  ( ws, param_sugar_list )?,
  ( ws?, LP, ws?, param_list?, ws?, RP )?,
  ws?, ARROW, ws?, type_ref,
  ( ws, requires_clause )?
;

proc_prefix     = "inline" | "static" | "extern" | "async" | "dedicate" ;

(* canonical parameter list *)
param_list      = param, { ws?, COMMA, ws?, param } ;
param           = ident, ws?, ":", ws?, type_ref ;

(* sugar parameter list: name type name type ... (no commas/colons/parens) *)
param_sugar_list= param_sugar, { ws, param_sugar } ;
param_sugar     = ident, ws, type_ref ;

stmt_list       = { stmt, opt_sep } ;

(*=============================================================================
  10) STATEMENTS (SUGAR + CANONICAL)
=============================================================================*)

stmt            = block_stmt
                | let_stmt
                | set_stmt
                | assign_stmt
                | mutate_stmt
                | add_by_stmt
                | if_stmt
                | while_stmt
                | for_stmt
                | return_stmt
                | try_stmt
                | throw_stmt
                | trap_stmt
                | halt_stmt
                | with_stmt
                | defer_stmt
                | lock_stmt
                | match_stmt
                | switch_stmt
                | decide_stmt
                | pragma_stmt
                | asm_stmt
                | io_stmt
                | mmio_stmt
                | goto_stmt
                | label_stmt
                | expr_stmt
                ;

block_stmt      = block_like(stmt_list) ;

(* declarations / bindings *)
let_stmt        =
    "let", ws, binding_sugar, ws?, "=", ws?, expr
  | "let", ws, binding_sugar                           (* allow “let x i64” if you want *)
  | "let", ws, binding_canon, ws?, "=", ws?, expr
  ;

set_stmt        =
    "set", ws, binding_sugar, ws, "to", ws, expr
  | "set", ws, lvalue, ws, "to", ws, expr              (* set h.version to 2 *)
  ;

binding_sugar   =
    ident, ( ws, type_ref )?                           (* x i64 *)
  | LP, ws?, bind_item, { ws?, COMMA?, ws?, bind_item }, ws?, RP  (* (x0 i64 x1 string ...) *)
  ;

bind_item       = ident, ws, type_ref ;

binding_canon   =
    ident, ws?, ":", ws?, type_ref
  | LP, ws?, ident, ws?, ":", ws?, type_ref, { ws?, COMMA, ws?, ident, ws?, ":", ws?, type_ref }, ws?, RP
  ;

assign_stmt     =
    lvalue, ws?, "=", ws?, expr
  | lvalue, ws, "to", ws, expr
  ;

mutate_stmt     = "mutate", ws, lvalue, ws, "to", ws, expr ;
add_by_stmt     = "add", ws, lvalue, ws, "by", ws, expr ;

(* control flow *)
if_stmt         =
    "if", ws, expr, ws?, block_like(stmt_list), ( ws?, "else", ws?, block_like(stmt_list) )?
  | "if", ws, expr, ws?, COLON, opt_sep, stmt_list, "end",
    ( opt_sep, "else", ws?, COLON, opt_sep, stmt_list, "end" )?
  ;

while_stmt      =
    "while", ws, expr, ws?, block_like(stmt_list)
  | "while", ws, expr, ws?, COLON, opt_sep, stmt_list, "end"
  ;

for_stmt        =
    "for", ws, for_header, ws?, block_like(stmt_list)
  | "for", ws, for_header, ws?, COLON, opt_sep, stmt_list, "end"
  ;

for_header      =
    (* C-style (your sugar still uses ; inside header) *)
    "let", ws, ident, ws, type_ref, ws?, "=", ws?, expr, ws?, ";", ws?, expr, ws?, ";", ws?, expr
  |
    (* canonical C-style typed let *)
    "let", ws, ident, ws?, ":", ws?, type_ref, ws?, "=", ws?, expr, ws?, ";", ws?, expr, ws?, ";", ws?, expr
  |
    (* range form *)
    "let", ws, ident, ( ws, type_ref )?, ws, "in", ws, expr, ws?, "..", ws?, expr
  ;

return_stmt     = ("return" | "ret"), ( ws, expr )? ;
throw_stmt      = "throw", ws, expr ;
trap_stmt       = "trap", ( ws, expr )? ;
halt_stmt       = "halt" ;

try_stmt        =
  "try", ws?, block_like(stmt_list),
  { opt_sep, catch_clause },
  ( opt_sep, finally_clause )?
|
  "try", ws?, COLON, opt_sep, stmt_list, "end",
  { opt_sep, "catch", ws, ident, ws?, COLON, opt_sep, stmt_list, "end" },
  ( opt_sep, "finally", ws?, COLON, opt_sep, stmt_list, "end" )?
;

catch_clause    =
    "catch", ws?, LP, ws?, ident, ws?, RP, ws?, block_like(stmt_list)
  | "catch", ws, ident, ws?, block_like(stmt_list)
  ;

finally_clause  = "finally", ws?, block_like(stmt_list) ;

(* sugar verbs: with / defer / lock *)
with_stmt       =
    "with", ws, callish, ( ws, "as", ws, ident )?, ws?, block_like(stmt_list)
  ;

defer_stmt      =
    "defer", ws, callish                              (* defer close f *)
  | "defer", ws?, block_like(stmt_list)
  ;

lock_stmt       =
    "lock", ws, expr, ws?, block_like(stmt_list)
  | "lock", ws?, LP, ws?, expr, ws?, RP, ws?, block_like(stmt_list)
  ;

(* matching: match / switch / decide *)
match_stmt      =
    "match", ws, expr, ws?, block_like(match_arm_list)
  | "match", ws, expr, ws?, COLON, opt_sep, match_arm_list, "end"
  ;

match_arm_list  = { match_arm, opt_sep } ;

match_arm       =
    "case", ws, pattern, ( ws, COLON, ws? )?, arm_body
  | "default", ( ws, COLON, ws? )?, arm_body
  ;

arm_body        =
    (* sugar: single-line arm: case 0: print "zero" *)
    stmt_single
  | block_like(stmt_list)
  ;

stmt_single     = stmt ; (* semantic: must be a single statement form *)

switch_stmt     =
    "switch", ws, expr, ws?, block_like(match_arm_list)
  | "switch", ws, expr, ws?, COLON, opt_sep, match_arm_list, "end"
  ;

decide_stmt     =
    "decide", ws, expr, ws?, block_like(match_arm_list)
  | "decide", ws, expr, ws?, COLON, opt_sep, match_arm_list, "end"
  ;

pattern         =
    "_" | int_lit | string_lit | bool_lit
  | ident                                        (* binder or variant name (resolved by CIAM/type) *)
  | ident, ws, ident                             (* sugar: Some x / None *)
  | ident, ws?, LP, ws?, ident, ws?, RP          (* canonical: Some(x) *)
  ;

(* pragmas as statements too *)
pragma_stmt     =
    "#pragma", ws, ident, ( ws, expr )?, (SEMI | nl | EOF)
  | "pragma", ws, string_lit, { ws, string_lit }, (SEMI | nl | EOF)
  | "pragma", ws, string_lit, ws, string_lit, (SEMI | nl | EOF)
  ;

pragma_decl     = pragma_stmt ;
define_decl     = "define", ws, ident, ws, const_expr, (SEMI | nl | EOF) ;

(* asm block forms: asm: ... end  OR  asm { ... } *)
asm_stmt        =
    "asm", ws?, COLON, opt_sep, asm_line+, "end"
  | "asm", ws?, LB, { ? asm_token ? }, RB
  ;

asm_line        = { ? not-end ? }, (nl | SEMI) ;

(* I/O-ish calls as statements are just expr_stmt; included here for readability *)
io_stmt         = expr_stmt ;

(* MMIO statement forms *)
mmio_stmt       =
    "read32", ws, ident, ws, expr, ws, "into", ws, ident
  | "write32", ws, ident, ws, expr, ws, expr
  ;

goto_stmt       =
    "goto", ws, goto_cond, ws?, "->", ws?, ident, ws?, COMMA?, ws?, ident
  ;
goto_cond       = expr | LP, ws?, expr, ws?, RP ;

label_stmt      =
    "label", ws, ident, (SEMI | nl | EOF)
  | "label", ws, ident, ws?, COLON
  | "label", ws, ident, ws?, SEMI
  ;

expr_stmt       = expr ;

(*=============================================================================
  11) EXPRESSIONS (supports both call styles)
=============================================================================*)

expr            = assign_expr ;

(* allow shorthand equality used as expression (c6 = a = b) *)
assign_expr     = ternary_expr, ( ws?, "=", ws?, ternary_expr )? ;

ternary_expr    = logical_or_expr, ( ws?, QMARK, ws?, expr, ws?, ":", ws?, expr )? ;

logical_or_expr = logical_and_expr, { ws?, ( "or" | "||" ), ws?, logical_and_expr } ;
logical_and_expr= bitxor_expr,      { ws?, ( "and" | "&&" ), ws?, bitxor_expr } ;

bitxor_expr     = bitor_expr,       { ws?, ( "xor" | "^" ), ws?, bitor_expr } ;
bitor_expr      = bitand_expr,      { ws?, "|", ws?, bitand_expr } ;
bitand_expr     = equality_expr,    { ws?, "&", ws?, equality_expr } ;

equality_expr   = compare_expr, { ws?, ( "==" | "!=" ), ws?, compare_expr } ;
compare_expr    = shift_expr,   { ws?, ( "<" | "<=" | ">" | ">=" ), ws?, shift_expr } ;

shift_expr      = additive_expr, { ws?, ( "shl" | "shr" | "sar" | "<<" | ">>" ), ws?, additive_expr } ;

additive_expr   = mult_expr, { ws?, ( "+" | "-" ), ws?, mult_expr } ;
mult_expr       = unary_expr, { ws?, ( "*" | "/" | "%" ), ws?, unary_expr } ;

unary_expr      =
    ( "-" | "!" | "not" | "~" ), ws?, unary_expr
  | postfix_expr
  ;

postfix_expr    = primary_expr, { postfix_tail } ;

postfix_tail    =
    (* canonical call: f(x, y) *)
    ws?, LP, ws?, arg_list?, ws?, RP
  | ws?, DOT, ws?, ident
  | ws?, LS, ws?, expr, ws?, RS
  ;

primary_expr    =
    literal
  | symbol_lit
  | struct_lit
  | array_lit
  | tuple_lit
  | choose_expr
  | spawn_expr
  | join_expr
  | await_expr
  | cast_expr
  | callish                              (* sugar call chaining *)
  | LP, ws?, expr, ws?, RP
  ;

literal         = int_lit | float_lit | string_lit | bool_lit | null_lit ;

(* sugar calls:  f x y   OR  f "https://example"   OR  rane_rt_net.fetch_i64 "https://example" *)
callish         =
    path_ident, ( ws, call_arg )+         (* at least one arg in verb-call form *)
  | path_ident, ws?, LP, ws?, arg_list?, ws?, RP
  ;

call_arg        = primary_expr ;

arg_list        = expr, { ws?, COMMA, ws?, expr } ;

(* struct literals: canonical + sugar *)
struct_lit       =
    (* canonical: Header{ magic: 1, ... } or Header: ... end (also used in node-prose) *)
    type_ref, ws?, LB, ws?, struct_kv_list?, ws?, RB
  | type_ref, ws?, COLON, opt_sep, struct_kv_list_sugar, "end"
  ;

struct_kv_list   = struct_kv, { ws?, COMMA, ws?, struct_kv } ;
struct_kv        = ident, ws?, ":", ws?, expr ;

struct_kv_list_sugar = { struct_kv_sugar, opt_sep } ;
struct_kv_sugar  = ident, ws, expr ;

array_lit        =
    LS, ws?, expr, { ws?, COMMA?, ws?, expr }, ws?, RS
  ;

tuple_lit        =
    LP, ws?, expr, { ws?, COMMA?, ws?, expr }, ws?, RP
  ;

choose_expr      =
    "choose", ws, ("max" | "min"), ws, expr, ws, expr
  | "choose", ws, ("max" | "min"), ws?, LP, ws?, expr, ws?, COMMA?, ws?, expr, ws?, RP
  ;

spawn_expr       =
    "spawn", ws, callish
  ;

join_expr        =
    "join", ws, expr
  ;

await_expr       =
    "await", ws, callish
  | "await", ws, expr
  ;

cast_expr        =
    expr, ws, "as", ws, type_ref
  ;

lvalue           =
    ident, { (ws?, DOT, ws?, ident) | (ws?, LS, ws?, expr, ws?, RS) }
  ;

(*=============================================================================
  12) NODE/PROSE MINI-LANGUAGE (sugar) + canonical node blocks
=============================================================================*)

(* The file can contain multiple “module X” occurrences; the parser treats them
   as separate module_decl items. Node/prose is a special module variant.
*)

node_module_group =
    node_module_decl, opt_sep, { node_item, opt_sep }, node_start_decl
  | node_module_decl, opt_sep, { node_item, opt_sep }   (* start may be omitted, semantic error *)
  ;

node_module_decl  = "module", ws, ident, (SEMI | nl | EOF) ;

node_item         = node_block_decl ;

node_block_decl   =
    "node", ws, ident, ws?, COLON, opt_sep,
      { node_stmt, opt_sep },
    "end"
  ;

node_start_decl   = "start", ws, "at", ws, "node", ws, ident, (SEMI | nl | EOF)? ;

node_stmt         =
    node_set_stmt
  | node_add_stmt
  | node_say_stmt
  | node_go_stmt
  | node_halt_stmt
  | node_trap_stmt
  ;

node_set_stmt     =
    "set", ws, ident, ws, type_ref, ws, "to", ws, node_value
  | "set", ws, lvalue, ws, "to", ws, expr
  | "set", ws, ident, ws, "to", ws, expr
  ;

(* node_value can be a struct_lit in sugar form: Header: ... end *)
node_value        = struct_lit | expr ;

node_add_stmt     = "add", ws, lvalue, ws, "by", ws, expr ;
node_say_stmt     = "say", ws, expr ;
node_go_stmt      = "go", ws, "to", ws, "node", ws, ident ;
node_halt_stmt    = "halt" ;
node_trap_stmt    = "trap", ( ws, expr )? ;

(*=============================================================================
  13) BLOCK FORMS
=============================================================================*)

(* block_like(X) means either:
    - canonical braces: { X }
    - sugar colon + end: : X end
*)

block_like(X)     = brace_block(X) | colon_end_block(X) ;

brace_block(X)    = LB, opt_sep, X, opt_sep, RB ;
colon_end_block(X)= COLON, opt_sep, X, opt_sep, "end" ;

(*=============================================================================
  14) CANONICAL-ONLY OPTIONALS (accepted everywhere)
=============================================================================*)

(* Allow semicolons after declarations in canonical files. Already included by opt_sep. *)

(*=============================================================================
  15) END
=============================================================================*)
