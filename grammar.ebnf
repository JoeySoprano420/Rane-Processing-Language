(*=============================================================================
  METADATA STRUCTURES
=============================================================================*)

struct ExecMetaHeader {
  u32 magic;          // 'RMET' = 0x54454D52
  u16 version;        // 1
  u16 flags;          // future
  u32 file_size;      // bytes
  u32 section_count;  // number of sections
  u32 section_table_off;
  u32 strtab_off;     // string table (NUL-terminated)
  u32 strtab_size;
  u32 symtab_off;     // symbol table (procedures/imports/globals)
  u32 symtab_count;
  u32 captab_off;     // capability table
  u32 cap_count;
  u32 proctab_off;    // per-proc metadata (caps + policy)
  u32 proc_count;
  u32 reserved[6];
};

struct ExecMetaSection {
  u32 name_str_off;   // offset into strtab
  u32 off;            // file offset
  u32 size;           // bytes
  u32 type;           // 1=strtab,2=symtab,3=captab,4=proctab
};

enum SymKind : u32 { SYM_PROC=1, SYM_IMPORT=2, SYM_GLOBAL=3 };

struct ExecMetaSymbol {
  u32 kind;           // SymKind
  u32 name_str_off;   // "namespace::proc"
  u32 linkage_id;     // compiler-assigned stable symbol id (@sym#) OR hash
  u32 aux_index;      // if kind==SYM_PROC: index into ProcMeta table
};

struct ExecMetaCap {
  u32 name_str_off;   // "heap_alloc"
  u32 cap_id;         // index (redundant but explicit)
  u32 flags;          // reserved (e.g., "dangerous", "io", "net")
  u32 reserved;
};

struct ProcMeta {
  u32 proc_sym_linkage_id;   // matches ExecMetaSymbol.linkage_id
  u32 caps_bitset_off;       // offset to u64 words in the caps blob
  u16 caps_word_count;       // number of u64 words
  u16 policy_flags;          // e.g., deterministic-only, no-jit, etc.
  u32 diag_name_str_off;     // optional display name
  u32 reserved;
};

struct ProcMetaList {
  u32 proc_sym_linkage_id;
  u32 cap_list_off;      // points into caplist blob
  u16 cap_count;
  u16 policy_flags;
  u32 reserved[2];
};

(*=============================================================================
  11) EXPRESSIONS (supports both call styles)
=============================================================================*)

expr            = assign_expr ;

(* allow shorthand equality used as expression (c6 = a = b) *)
assign_expr     = ternary_expr, ( ws?, "=", ws?, assign_expr )? ;

ternary_expr    = logical_or_expr, ( ws?, QMARK, ws?, expr, ws?, ":", ws?, expr )? ;

logical_or_expr = logical_and_expr, { ws?, ( "or" | "||" ), ws?, logical_and_expr } ;
logical_and_expr= bitxor_expr,      { ws?, ( "and" | "&&" ), ws?, bitxor_expr } ;

bitxor_expr     = bitor_expr,       { ws?, ( "xor" | "^" ), ws?, bitor_expr } ;
bitor_expr      = bitand_expr,      { ws?, "|", ws?, bitand_expr } ;
bitand_expr     = equality_expr,    { ws?, "&", ws?, equality_expr } ;

equality_expr   = compare_expr, { ws?, ( "==" | "!=" ), ws?, compare_expr } ;
compare_expr    = shift_expr,   { ws?, ( "<" | "<=" | ">" | ">=" ), ws?, shift_expr } ;

shift_expr      = additive_expr, { ws?, ( "shl" | "shr" | "sar" | "<<" | ">>" ), ws?, additive_expr } ;

additive_expr   = mult_expr, { ws?, ( "+" | "-" ), ws?, mult_expr } ;
mult_expr       = unary_expr, { ws?, ( "*" | "/" | "%" ), ws?, unary_expr } ;

unary_expr      =
    ( "-" | "!" | "not" | "~" ), ws?, unary_expr
  | postfix_expr
  ;

postfix_expr    = primary_expr, { postfix_tail } ;

postfix_tail    =
    (* canonical call: f(x, y) *)
    ws?, LP, ws?, arg_list?, ws?, RP
  | ws?, DOT, ws?, ident
  | ws?, LS, ws?, expr, ws?, RS
  | ws, "as", ws, type_ref
  ;

primary_expr    =
    literal
  | symbol_lit
  | struct_lit
  | array_lit
  | tuple_lit
  | choose_expr
  | spawn_expr
  | join_expr
  | await_expr
  | callish                              (* sugar call chaining *)
  | LP, ws?, expr, ws?, RP
  ;

literal         = int_lit | float_lit | string_lit | bool_lit | null_lit ;

(* Lowering for loops:
   - convert to structured control flow (CF) graphs
   - allow sharing of exit nodes
  Translation:
   for init; cond; iter
    {
      body
    }
   =>
   B.entry:
     <lower_init>
     Jmp B.while.header
   
   B.while.header:
     %c = <lower_cond_expr_into_temp>         ; yields i32/i64 predicate
     JmpIfZero %c, B.while.exit, B.while.body
   
   B.while.body:
     <lower_body_statements>
     Jmp B.while.header
   
   B.while.exit:
     ; continues with following code

   for init, cond, iter:
   {
     body
   }
   =>
   B.entry:
     <lower_init_stmt>                          ; e.g., let i: i64 = 0
     Jmp B.for.header
  
   B.for.header:
     %c = <lower_cond_expr_into_temp>
     JmpIfZero %c, B.for.exit, B.for.body
  
   B.for.body:
     <lower_body_statements>
     Jmp B.for.step
  
   B.for.step:
     <lower_step_expr_or_stmt>                ; e.g., i = i + 1
     Jmp B.for.header
  
   B.for.exit:
     ; continues
*)
; in B.entry
%a0 = <lower_expr a>
%b0 = <lower_expr b>
Jmp B.for.header

B.for.header:
  %i = Phi (B.entry: %a0), (B.for.step: %i2)
  %c = CmpLT %i, %b0
  JmpIfZero %c, B.for.exit, B.for.body

B.for.body:
  <lower_body_statements using %i>
  Jmp B.for.step

B.for.step:
  %one = ConstI64 1
  %i2 = Add %i, %one
  Jmp B.for.header

B.for.exit:

; assume we're in some block and want %r
%a = <lower a>
JmpIfZero %a, B.and.false, B.and.eval_b

B.and.eval_b:
  %b = <lower b>
  JmpIfZero %b, B.and.false, B.and.true

B.and.false:
  %r0 = ConstI32 0
  Jmp B.and.join

B.and.true:
  %r1 = ConstI32 1
  Jmp B.and.join

B.and.join:
  %r = Phi (B.and.false: %r0), (B.and.true: %r1)

%a = <lower a>
JmpIfZero %a, B.or.test_b, B.true

B.or.test_b:
  %b = <lower b>
  JmpIfZero %b, B.false, B.true

B.false:
  %r0 = ConstI32 0
  Jmp B.or.join

B.true:
  %r1 = ConstI32 1
  Jmp B.or.join

B.or.join:
  %r = Phi (B.or.false: %r0), (B.or.true: %r1)

; want: if (a and b) goto B.true else B.false

%a = <lower a>
JmpIfZero %a, B.false, B.and.test_b

B.and.test_b:
  %b = <lower b>
  JmpIfZero %b, B.false, B.true

Jmp B1
B1:
  %x = Load %slot_x
  %ten = ConstI64 10
  %c = CmpLT %x, %ten
  JmpIfZero %c, B3, B2
B2:
  ...
  Jmp B1
B3:
